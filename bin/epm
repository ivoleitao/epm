#!/usr/bin/env bash

# Add semantics to avoid packing without all the dependencies installed (remove work around in packages)
# Correct problem with command_fail
# Add best practices set command to epm
# Add dynamic dependencies
# Support for package configuration
# Push only if updated
# Add win support
# Allow the listing of uninstalled packages 
# Add support for listing via webdav
# Adicionar biblioteca epm e resolver problema com jdev no wait for process

VERSION_NUMBER="0.0.1"
VERSION_DATE="04/07/2015"
PROGRAM_FILE="$(basename $0)"
PROGRAM_NAME="${PROGRAM_FILE%.*}"
PROGRAM_PATH="$(command -v $0)"
EPM_DIR=".$PROGRAM_NAME"
TERM_COLS=$(tput cols)
TERM_NORMAL=$(tput sgr0)
TERM_BOLD=$(tput bold)
TERM_RED=$(tput setaf 1)
TERM_GREEN=$(tput setaf 2)
TERM_YELLOW=$(tput setaf 3)
TERM_BLUE=$(tput setaf 4)
TERM_PURPLE=$(tput setaf 5)
TERM_CYAN=$(tput setaf 6)
TERM_GRAY=$(tput setaf 7)

OS_ALL="all"
OS_NIX="nix"
OS_WIN="win"
PKG_EXT="pkg"
YML_EXT="yml"
TRACE_LEVEL_VALUE="1"
TRACE_LEVEL_NAME="trace"
DEBUG_LEVEL_VALUE="2"
DEBUG_LEVEL_NAME="debug"
INFO_LEVEL_VALUE="3"
INFO_LEVEL_NAME="info"
WARN_LEVEL_VALUE="4"
WARN_LEVEL_NAME="warn"
ERROR_LEVEL_VALUE="5"
ERROR_LEVEL_NAME="error"
FATAL_LEVEL_VALUE="6"
FATAL_LEVEL_NAME="fatal"
declare -A LOG_LEVELS=( [$TRACE_LEVEL_NAME]="$TRACE_LEVEL_VALUE" [$DEBUG_LEVEL_NAME]="$DEBUG_LEVEL_VALUE" [$INFO_LEVEL_NAME]="$INFO_LEVEL_VALUE" [$WARN_LEVEL_NAME]="$WARN_LEVEL_VALUE" [$ERROR_LEVEL_NAME]="$ERROR_LEVEL_VALUE" [$FATAL_LEVEL_NAME]="$FATAL_LEVEL_VALUE"  )
EPM_DEFAULT_LOG_NAME=$TRACE_LEVEL_NAME
EPM_DEFAULT_LOG_VALUE=${LOG_LEVELS[$EPM_DEFAULT_LOG_NAME]}
EPM_ENV_FILE_NAME="env.sh"
EPM_LIB_FILE_NAME="lib.sh"
EPM_DAT_FILE_NAME="data.yml"
EPM_LOG_FILE_NAME="${PROGRAM_NAME}.log"
PKG_METADATA_SOURCE_ORIGIN="origin"
PKG_METADATA_SOURCE_LOCAL="local"
PKG_METADATA_SOURCE_REMOTE="remote"
PKG_METADATA_SOURCE_AUTO="auto"
PKG_DEPENDENTS_MODE_PARENT="parent"
PKG_DEPENDENTS_MODE_DEPENDENCIES="dependencies"
PKG_DEPENDENTS_MODE_ALL="all"
PKG_PACK_FILE_NAME="pack.sh"
PKG_METADATA_FILE_NAME="package.yml"
PKG_INSTALL_FILE_NAME="install.sh"
PKG_UNINSTALL_FILE_NAME="uninstall.sh"
PKG_TYPE_SINGLE="single"
PKG_TYPE_BUNDLE="bundle"

ROOT_PATH="$(pwd)"
BIN_PATH="$ROOT_PATH/bin"
LIB_PATH="$ROOT_PATH/lib"
ETC_PATH="$ROOT_PATH/etc"
VAR_PATH="$ROOT_PATH/var"
LOG_PATH="$VAR_PATH/log"
TMP_PATH="$ROOT_PATH/tmp"
APP_PATH="$ROOT_PATH/app"
WS_PATH="$ROOT_PATH/ws"
WWW_PATH="$ROOT_PATH/www"
EPM_PATH="$ROOT_PATH/$EPM_DIR"
EPM_ENV_FILE_PATH="$EPM_PATH/$EPM_ENV_FILE_NAME"
EPM_LIB_FILE_PATH="$EPM_PATH/$EPM_LIB_FILE_NAME"
EPM_DAT_FILE_PATH="$EPM_PATH/$EPM_DAT_FILE_NAME"
EPM_CFG_PATH="$ETC_PATH/epm"
EPM_BIN_PATH="$EPM_PATH/bin"
EPM_LIB_PATH="$EPM_PATH/lib"
EPM_PKG_PATH="$EPM_PATH/pkg"
EPM_STG_PATH="$EPM_PATH/stg"
EPM_LOG_PATH="$EPM_PATH/log"
EPM_LOG_FILE_PATH="$EPM_LOG_PATH/$EPM_LOG_FILE_NAME"

PROGRAM_PATH_KEY="PROGRAM_PATH"
ROOT_PATH_KEY="ROOT_PATH"
BIN_PATH_KEY="BIN_PATH"
LIB_PATH_KEY="LIB_PATH"
ETC_PATH_KEY="ETC_PATH"
VAR_PATH_KEY="VAR_PATH"
LOG_PATH_KEY="LOG_PATH"
TMP_PATH_KEY="TMP_PATH"
APP_PATH_KEY="APP_PATH"
WS_PATH_KEY="WS_PATH"
WWW_PATH_KEY="WWW_PATH"
EPM_CFG_PATH_KEY="EPM_CFG_PATH"
EPM_BIN_PATH_KEY="EPM_BIN_PATH"
EPM_LIB_PATH_KEY="EPM_LIB_PATH"
EPM_PKG_PATH_KEY="EPM_PKG_PATH"
EPM_STG_PATH_KEY="EPM_STG_PATH"
EPM_PKG_SRV_KEY="EPM_PKG_SRV"
EPM_LOG_PATH_KEY="EPM_LOG_PATH"

PKG_SHA1_KEY="sha1"
PKG_TIMESTAMP_KEY="timestamp"
PKG_TENANT_KEY="tenant"
PKG_TYPE_KEY="type"
PKG_OS_KEY="os"
PKG_PARENT_KEY="parent"
PKG_DEPENDENCIES_KEY="dependencies"
PKG_DESCRIPTION_KEY="description"

initialized() {
    test -f "$EPM_LOG_FILE_PATH"
}

get_timestamp() {
    date +%s
}

log() {
    local LEVEL_NAME="$1"
    local MSG="$2"
    local LOG_VALUE=${LOG_LEVELS[$LEVEL_NAME]}
    
    if initialized; then
        if [ $LOG_VALUE -ge $EPM_DEFAULT_LOG_VALUE ]; then
            echo "$(date +'%d-%m-%Y %H:%M:%S') $MSG" >> "$EPM_LOG_FILE_PATH"
        fi
    fi
}

log_trace() {
    log "$TRACE_LEVEL_NAME" "[TRACE] - $1"
}

log_debug() {
    log "$DEBUG_LEVEL_NAME" "[DEBUG] - $1"
}

log_info() {
    log "$INFO_LEVEL_NAME" "[INFO] - $1"
}

log_warn() {
    log "$WARN_LEVEL_NAME" "[WARN] - $1"
}

log_error() {
    log "$ERROR_LEVEL_NAME" "[ERROR] - $1"
}

log_fatal() {
    log "$FATAL_LEVEL_NAME" "[FATAL] - $1"
}

save_cursor() {
    tput sc
}

restore_cursor() {
    tput rc
}

clean_to_end_line() {
    tput el
}

empty() {
    log_trace "Checking if parameter \"$1\" is empty"
    test -z "$1"
}

trim() {
    log_trace "Trimming leading and trailing spaces from \"$1\""
    echo -e "$1" | sed -e "s/^[[:space:]]*//" -e "s/[[:space:]]*$//"
}

replace() {
    log_trace "Replacing \"$2\" with \"$3\" in \"$1\""
    sed -r "s/$2/$3/g" <<< $1 
}

reverse() {
    log_trace "Reversing text \"$1\""
    sed -n '1!G;h;$p' <<< "$1"
}

csv_contains() {
    log_trace "Checking if csv list \"$1\" has the \"$2\" element"
    IFS=',' read -ra VALUES <<< "$1"
    for VALUE in "${VALUES[@]}"; do
        local TVALUE="$(trim "$VALUE")"
        if [[ "$TVALUE" == "$2" ]]; then
            return 0
        fi
    done

    return 1
}

file_list() {
    log_trace "Listing files in directory \"$1\""
    while read -r FILE; do
        if ! empty "$FILE"; then
            echo $(basename -- "$FILE")
        fi   
    done <<< "$(ls -d -- $1/* 2>/dev/null)"
}

file_exists() {
    log_trace "Checking if file \"$1\" exists"
    test -f "$1"
}

file_empty() {
    log_trace "Checking if file \"$1\" is empty"
    ! test -s "$1"
}

file_create() {
    log_trace "Creating file \"$1\""
    touch "$1"
}

file_delete() {
    log_trace "Deleting file \"$1\""
    rm -f "$1"
}

file_copy() {
    log_trace "Copying file \"$1\" to \"$2\""
    cp "$1" "$2"
}

file_move() {
    log_trace "Moving file \"$1\" to \"$2\""
    mv "$1" "$2"
}

file_executable() {
    log_trace "Making file \"$1\" executable"
    chmod +x "$1"
}

file_truncate() {
    log_trace "Truncating file \"$1\""
    truncate -s 0 "$1"
}

file_equal() {
    if grep -v -F -x -f $1 $2; then
         return 1
    else
        return 0
    fi          
}

file_read() {
    cat "$1"
}

dir_list() {
    log_trace "Listing folders in directory \"$1\""
    while read -r DIR; do
        if ! empty "$DIR"; then
            DIR=${DIR%*/}
            echo ${DIR##*/}
        fi   
    done <<< "$(ls -d -- $1/*/ 2>/dev/null)"
}

dir_exists() {
    log_trace "Checking if directory \"$1\" exists"
    test -d "$1"
}

dir_create() {
    log_trace "Creating directory \"$1\""
    mkdir -p "$1"
}

dir_delete() {
    log_trace "Deleting directory \"$1\""
    rm -Rf "$1"
}

dir_checksum() {
    log_trace "Calculating checksum of directory \"$1\""
    find "$1" -type f -print0 | sort -z | xargs -0 sha1sum | cut -d" " -f1 | sha1sum | cut -d" " -f1
}

url_valid() {
    log_trace "Checking if \"$1\" is a valid url"
    URL_REGEX="(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]"
    [[ $1 =~ $URL_REGEX ]]
}

url_file_exists() {
    log_trace "Checking if file \"$1\" exists"
    curl --output /dev/null --silent --head --fail "$1"
}

url_file_download() {
    log_trace "Downloading file \"$1\""
    if [ "$#" -eq 2 ]; then
        curl --silent --fail -o "$1" "$2"
    else
        curl --silent --fail "$1"
    fi
}

url_file_upload() {
    log_trace "Uploading file \"$1\""
    curl --fail --silent -T "$1" "$2"
}

archive_create() {
    log_trace "Creating archive \"$1\" from \"$2\""
    tar czf "$1" -C "$2" .
}

archive_extract() {
    log_trace "Extracting archive \"$1\" to \"$2\""
    tar xzf "$1" -C "$2"
}

yesNo() {
    log_trace "Querying the user"
    while true; do
        read -p "$1" YN
        YN=${YN,,}
        case $YN in
            y|yes) 
                log_trace "Response was yes ($YN)"
                break
                ;;
            n|no) 
                log_trace "Response was no ($YN)"
                exit 0
                ;;
        esac
    done
}

print_table1() {
    HEADER_COL="$1"
    COL_LEN=0
    ROW_DATA=()
    while read -r ROW; do
        COL="$ROW"
        TMP=${#COL}
        COL_LEN=$(( TMP > COL_LEN ? TMP : COL_LEN ))
        ROW_DATA+=("$COL")
    done

    if [ "${#ROW_DATA}" -gt "0" ]; then
        printf "$TERM_BOLD$TERM_YELLOW%-${COL_LEN}s$TERM_NORMAL\n" "$HEADER_COL"
        
        for ROW in "${ROW_DATA[@]}"; do
            COL="$ROW"

            printf "%-${COL1_LEN}s\n" "$COL"
        done
    fi
}

print_table2() {
    HEADER_COL1="$1"
    HEADER_COL2="$2"
    COL1_LEN=0
    COL2_LEN=0
    ROW_DATA=()
    while read -r ROW; do
        COL1="$(cut -d' ' -f1 <<< "$ROW")"
        COL2="$(cut -d' ' -f2 <<< "$ROW")"
        TMP1=${#COL1}
        TMP2=${#COL2}
        COL1_LEN=$(( TMP1 > COL1_LEN ? TMP1 : COL1_LEN ))
        COL2_LEN=$(( TMP2 > COL2_LEN ? TMP2 : COL2_LEN ))
        ROW_DATA+=("$COL1 $COL2")
    done

    if [ "${#ROW_DATA}" -gt "0" ]; then
        printf "$TERM_BOLD$TERM_YELLOW%-${COL1_LEN}s$TERM_NORMAL|$TERM_BOLD$TERM_YELLOW%-${COL2_LEN}s$TERM_NORMAL\n" "$HEADER_COL1" "$HEADER_COL2"
        
        for ROW in "${ROW_DATA[@]}"; do
            COL1="$(cut -d' ' -f1 <<< "$ROW")"
            COL2="$(cut -d' ' -f2 <<< "$ROW")"

            printf "%-${COL1_LEN}s|%-${COL2_LEN}s\n" "$COL1" "$COL2"
        done
    fi
}

print_table3() {
    HEADER_COL1="$1"
    HEADER_COL2="$2"
    HEADER_COL3="$3"
    COL1_LEN=0
    COL2_LEN=0
    COL3_LEN=0
    ROW_DATA=()
    while read -r ROW; do
        COL1="$(cut -d' ' -f1 <<< "$ROW")"
        COL2="$(cut -d' ' -f2 <<< "$ROW")"
        COL3="$(cut -d' ' -f3 <<< "$ROW")"
        TMP1=${#COL1}
        TMP2=${#COL2}
        TMP3=${#COL3}
        COL1_LEN=$(( TMP1 > COL1_LEN ? TMP1 : COL1_LEN ))
        COL2_LEN=$(( TMP2 > COL2_LEN ? TMP2 : COL2_LEN ))
        COL3_LEN=$(( TMP3 > COL3_LEN ? TMP3 : COL3_LEN ))
        ROW_DATA+=("$COL1 $COL2 $COL3")
    done

    if [ "${#ROW_DATA}" -gt "0" ]; then
        printf "$TERM_BOLD$TERM_YELLOW%-${COL1_LEN}s$TERM_NORMAL|$TERM_BOLD$TERM_YELLOW%-${COL2_LEN}s$TERM_NORMAL|$TERM_BOLD$TERM_YELLOW%-${COL3_LEN}s$TERM_NORMAL\n" "$HEADER_COL1" "$HEADER_COL2" "$HEADER_COL3"
        
        for ROW in "${ROW_DATA[@]}"; do
            COL1="$(cut -d' ' -f1 <<< "$ROW")"
            COL2="$(cut -d' ' -f2 <<< "$ROW")"
            COL2="$(cut -d' ' -f3 <<< "$ROW")"

            printf "%-${COL1_LEN}s|%-${COL2_LEN}s|%-${COL3_LEN}s\n" "$COL1" "$COL2" "$COL3"
        done
    fi
}

command_begin() {
    local MSG="$1"
    local STATUS="$2"
    STATUS="${STATUS:-"RUNNING"}"
    
    printf "%s: " "$MSG"
    save_cursor
    printf "[$TERM_BLUE""$STATUS""$TERM_NORMAL]"
}

command_step() {
    local STATUS="$1"

    restore_cursor
    clean_to_end_line
    save_cursor
    printf "[$TERM_BLUE""$STATUS""$TERM_NORMAL]"
}

download_step() {
    command_step "DOWNLOAD"
}

running_step() {
    command_step "RUNNING"
}

command_end() {
    local STATUS="$1"
    local MSG="$2"

    restore_cursor
    clean_to_end_line
    if empty "$MSG"; then
        printf "[$TERM_GREEN""$STATUS""$TERM_NORMAL]\n"
    else
        printf "[$TERM_RED""$STATUS""$TERM_NORMAL][%s]\n" "$MSG"
    fi
}

command_ok() {
    command_end "OK"
}

command_fail() {
    command_end "FAIL" "${1:-}"
    exit 1
}

error() {
    log_debug "Exiting $PROGRAM_FILE on error with message \"$1\""
    printf "%s\n" "$1"
    exit 1
}

usage() { 
    log_trace "Printing usage"

    printf "usage:$PROGRAM_FILE [--version] [--help] | <command> <args>\n"
    printf "${PROGRAM_FILE^} commands:\n"
    printf "\tinit\t\tInitializes the environment\n"
    printf "\tenv\t\tGet and set $PROGRAM_NAME environment\n"
    printf "\tpull\t\tFetches a package\n"
    printf "\tinstall\t\tInstalls a package\n"
    printf "\tuninstall\tUninstalls a package\n"
    printf "\tpurge\t\tPurges a package\n"
    printf "\tpack\t\tCreates a package\n"
    printf "\tpush\t\tSends a new version of the package to the package server\n"
    printf "\tupdate\t\tUpdates one or more packages\n"
    printf "\tlist\t\tLists all the packages installed locally\n"
    printf "\tversion\t\tDisplays program version\n"
    printf "\thelp\t\tDisplays program help information\n"
}

command_usage() {
    USAGE_CMD=$1
    USAGE_CMD_SYNOPSIS=$2
    USAGE_CMD_DESCRIPTION=$3
    USAGE_MSG=$4
    
    log_trace "Printing command usage with message \"$USAGE_MSG\""

    ! empty "$USAGE_MSG" && printf "%b\n\n" "$USAGE_MSG" 
    printf "usage: %s %s %s\n" "$PROGRAM_NAME" "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS"
    ! empty "$USAGE_CMD_DESCRIPTION" && printf "%b\n" "$USAGE_CMD_DESCRIPTION" 
    exit 1
}

check() {
    log_trace "Checking base conditions"
    if ! file_exists "$EPM_ENV_FILE_PATH"; then
        printf "fatal: %s is not not a %s folder\n" "$EPM_ENV_FILE_PATH" "$PROGRAM_NAME"
        exit 1
    fi
}

function parse_yaml {
    log_trace "Parsing yaml file"

    local s='[[:space:]]*' w='[a-zA-Z0-9_]*' fs=$(echo @|tr @ '\034')
    sed -ne "s|^\($s\):|\1|" \
        -e "s|^\($s\)\($w\)$s:$s[\"']\(.*\)[\"']$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)$s:$s\(.*\)$s\$|\1$fs\2$fs\3|p" |
    awk -F$fs '{
      indent = length($1)/2;
      vname[indent] = $2;
      for (i in vname) {if (i > indent) {delete vname[i]}}
      if (length($3) > 0) {
         vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])(":")}
         printf("%s%s=%s\n",vn, $2, $3);
      }
    }'
}

is_package() {
    log_trace "Checking if \"$1\" is a package"
    [[ "$1" =~ ^[a-zA-Z]{1}[_a-zA-Z0-9]+$ ]]
}

prop_exists() {
    log_trace "Checking if key \"$1\" exists in \"$2\""
    grep -q "$1=" "$2"
}

prop_add() {
    log_trace "Adding key \"$1\" with value \"$2\" to \"$3\""
    echo "$1=$2" >> "$3"
}

prop_remove() {
    log_trace "Removing key \"$1\" from \"$2\""
    sed -i "/$1=/d" "$2"
}

prop_get() {
    if [ "$#" -eq 2 ]; then
        log_trace "Getting key \"$1\" value from \"$2\""
        grep -Po "(?<=^$1=).*" "$2"
    else
        log_trace "Getting key \"$1\" value from stdin"
        while read DATA; do
            grep -Po "(?<=^$1=).*" <<< "$DATA"
        done
    fi
}

prop_set() {
    log_trace "Setting property \"$1\" with value \"$2\" in \"$3\""
    sed -i "s|$1=.*|$1=$2|g" "$3"
}

var_exists() {
    prop_exists "export $1" "$EPM_ENV_FILE_PATH"
}

var_add() {
    prop_add "export $1" "$2" "$EPM_ENV_FILE_PATH"
}

var_remove() {
    prop_remove "export $1" "$EPM_ENV_FILE_PATH"
}

var_get() {
    prop_get "export $1" "$EPM_ENV_FILE_PATH"
}

var_set() {
    prop_set "export $1" "$2" "$EPM_ENV_FILE_PATH"
}

var_list() {
    log_trace "Listing variables in \"$EPM_ENV_FILE_PATH\""
    sed -r "s|export (.*)=(.*)|\1 \2|" "$EPM_ENV_FILE_PATH"
}

pkg_os() {
    PKG="$1"
    PKG_PATH="$EPM_PKG_PATH/$PKG"

    log_trace "Obtaining the \"$PKG\" os"
    if dir_exists "$PKG_PATH/$OS_ALL"; then
        log_trace "Returning $OS_ALL"
        echo "$OS_ALL"
    elif dir_exists "$PKG_PATH/$OS_NIX"; then
        log_trace "Returning $OS_NIX"
        echo "$OS_NIX"
    fi
}

pkg_metadata_new() {
    local PKG_PARAM="$1"
    local SHA1_PARAM="$2"
    local TIMESTAMP_PARAM="$3"
    local TENANT_PARAM="$4"
    local TYPE_PARAM="$5"
    local PARENT_PARAM="$6"
    local DEPENDENCIES_PARAM="$7"
    local DESCRIPTION_PARAM="$8"
    local FILE_PATH_PARAM="$9"

    log_trace "Adding package \"$PKG_PARAM\" with sha1 equals to \"$SHA1_PARAM\", timestamp equals to \"$TIMESTAMP_PARAM\", tenant equals to \"$TENANT_PARAM\", type equals to \"$TYPE_PARAM\", parent equals to \"$PARENT_PARAM\", dependencies equal to \"$DEPENDENCIES_PARAM\" and description equals to \"$DESCRIPTION_PARAM\" to \"$EPM_DAT_FILE_PATH\""

    echo "$PKG_PARAM:" >> "$FILE_PATH_PARAM"
    echo "  $PKG_SHA1_KEY: $SHA1_PARAM" >> "$FILE_PATH_PARAM"
    echo "  $PKG_TIMESTAMP_KEY: $TIMESTAMP_PARAM" >> "$FILE_PATH_PARAM"
    echo "  $PKG_TENANT_KEY: $TENANT_PARAM" >> "$FILE_PATH_PARAM"
    echo "  $PKG_TYPE_KEY: $TYPE_PARAM" >> "$FILE_PATH_PARAM"
    echo "  $PKG_PARENT_KEY: $PARENT_PARAM" >> "$FILE_PATH_PARAM"
    echo "  $PKG_DEPENDENCIES_KEY: $DEPENDENCIES_PARAM" >> "$FILE_PATH_PARAM"
    echo "  $PKG_DESCRIPTION_KEY: $DESCRIPTION_PARAM" >> "$FILE_PATH_PARAM"
}

pkg_metadata_origin_get() {
    PKG="$1"
    PKG_METADATA_PATH="$2"
    
    if ! empty "$PKG_METADATA_PATH"; then
        PKG_OS="$(pkg_os "$PKG")"
        PKG_SRC_PATH="$EPM_PKG_PATH/$PKG/$PKG_OS"
        PKG_METADATA_PATH="$PKG_SRC_PATH/$PKG_METADATA_FILE_NAME"
    fi
    if file_exists "$PKG_METADATA_PATH"; then
        file_read "$PKG_METADATA_PATH" | parse_yaml
    fi
}

pkg_metadata_local_get() {
    PKG="$1"
    PKG_METADATA_PATH="$2"

    if ! empty "$PKG_METADATA_PATH"; then
        PKG_OS="$(pkg_os "$PKG")"
        PKG_PATH="$EPM_PKG_PATH/$PKG"
        PKG_METADATA_PATH="$PKG_PATH/$PKG-$PKG_OS.$YML_EXT"
    fi
    if file_exists "$PKG_METADATA_PATH"; then
        file_read "$PKG_METADATA_PATH" | parse_yaml
    fi
}

pkg_metadata_remote_get() {
    PKG="$1"

    EPM_PKG_SRV="$(var_get $EPM_PKG_SRV_KEY)"
    YML_FILE_ALL="$PKG-$OS_ALL.$YML_EXT"
    YML_FILE_NIX="$PKG-$OS_NIX.$YML_EXT"
    YML_SRV_ALL="$EPM_PKG_SRV/$YML_FILE_ALL"
    YML_SRV_NIX="$EPM_PKG_SRV/$YML_FILE_NIX"
    if url_file_exists "$YML_SRV_ALL"; then
        log_debug "Package for all exists in the server"
        YML_URL="$YML_SRV_ALL"
    elif url_file_exists "$YML_SRV_NIX"; then
        log_debug "Package for nix exists in the server"
        YML_URL="$YML_SRV_NIX"
    fi
    if ! empty "$YML_URL"; then
         url_file_download "$YML_URL" | parse_yaml
    fi
}

pkg_metadata_auto_get() {
    PKG="$1"
    PKG_OS="$(pkg_os "$PKG")"
    PKG_PATH="$EPM_PKG_PATH/$PKG"
    PKG_SRC_PATH="$PKG_PATH/$PKG_OS"
    PKG_METADATA_ORIGIN_PATH="$PKG_SRC_PATH/$PKG_METADATA_FILE_NAME"
    PKG_METADATA_LOCAL_PATH="$PKG_PATH/$PKG-$PKG_OS.$YML_EXT"

    if file_exists "$PKG_METADATA_LOCAL_PATH"; then
        pkg_metadata_local_get "$PKG" "$PKG_METADATA_LOCAL_PATH"
    elif file_exists "$PKG_METADATA_ORIGIN_PATH"; then
        pkg_metadata_origin_get "$PKG" "$PKG_METADATA_ORIGIN_PATH"
    else 
        pkg_metadata_remote_get "$PKG"
    fi
}

pkg_metadata_get() {
    PKG="$1"
    PKG_SOURCE="$2"
    PKG_SOURCE="${PKG_SOURCE:-$PKG_METADATA_SOURCE_AUTO}"

    case "$PKG_SOURCE" in
        $PKG_METADATA_SOURCE_ORIGIN)
            log_debug "Getting package metadata from origin"
            pkg_metadata_origin_get "$PKG"
            ;;
        $PKG_METADATA_SOURCE_LOCAL)
            log_debug "Getting package metadata from local"
            pkg_metadata_local_get "$PKG"
            ;;
        $PKG_METADATA_SOURCE_REMOTE)
            log_debug "Getting package metadata from remote"
            pkg_metadata_remote_get "$PKG"
            ;;
        $PKG_METADATA_SOURCE_AUTO)
            log_debug "Calculating package source"
            pkg_metadata_auto_get "$PKG"
            ;;
    esac
}

pkg_metadata_get_prop() {
    pkg_metadata_get "$1" "$3" | prop_get "$1:$2" 
}

pkg_metadata_list_prop() {
    pkg_metadata_get "$1" "$3" | sed -r "s|(.*):(.*)=(.*)|\2 \3|"
}

pkg_metadata_get_sha1() {
    pkg_metadata_get_prop "$1" "$PKG_SHA1_KEY" "$2" 
}

pkg_metadata_get_timestamp() {
    pkg_metadata_get_prop "$1" "$PKG_TIMESTAMP_KEY" "$2"
}

pkg_metadata_get_tenant() {
    pkg_metadata_get_prop "$1" "$PKG_TENANT_KEY" "$2"
}

pkg_metadata_get_type() {
    pkg_metadata_get_prop "$1" "$PKG_TYPE_KEY" "$2"
}

pkg_metadata_get_parent() {
    pkg_metadata_get_prop "$1" "$PKG_PARENT_KEY" "$2" 
}

pkg_metadata_get_dependencies() {
    pkg_metadata_get_prop "$1" "$PKG_DEPENDENCIES_KEY" "$2" 
}

pkg_metadata_get_description() {
    pkg_metadata_get_prop "$1" "$PKG_DESCRIPTION_KEY" "$2" 
}

pkg_config_file_path() {
    local PKG="$1"
    local PKG_CONFIG_FILE_NAME="${PKG}.properties"
    local PKG_CONFIG_FILE_PATH="$EPM_CFG_PATH/$PKG_CONFIG_FILE_NAME"

    echo "$PKG_CONFIG_FILE_PATH"
}

pkg_config_exists() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    file_exists "$PKG_CONFIG_FILE_PATH"
}

pkg_config_exists_prop() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    prop_exists "$2" "$PKG_CONFIG_FILE_PATH"
}

pkg_config_add_prop() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    prop_add "$2" "$3" "$PKG_CONFIG_FILE_PATH"
}

pkg_config_remove_prop() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    prop_remove "$2" "$PKG_CONFIG_FILE_PATH"
}

pkg_config_get_prop() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    prop_get "$2" "$PKG_CONFIG_FILE_PATH"
}

pkg_config_set_prop() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    prop_set "$2" "$3" "$PKG_CONFIG_FILE_PATH"
}

pkg_config_list_prop() {
    local PKG_CONFIG_FILE_PATH="$(pkg_config_file_path "$1")"

    log_trace "Listing properties in \"$PKG_CONFIG_FILE_PATH\""

    sed -r "s|(.*)=(.*)|\1 \2|" "$PKG_CONFIG_FILE_PATH"
}

data_pkg_add() {
    local PKG_PARAM="$1"
    local TYPE_PARAM="$2"
    local OS_PARAM="$3"
    local PARENT_PARAM="$4"
    local DEPENDENCIES_PARAM="$5"
    local DESCRIPTION_PARAM="$6"

    log_trace "Adding package \"$PKG_PARAM\" with type equals to \"$TYPE_PARAM\", os equals to \"$OS_PARAM\", parent equals to \"$PARENT_PARAM\", dependencies equal to \"$DEPENDENCIES_PARAM\" and description equals to \"$DESCRIPTION_PARAM\" to \"$EPM_DAT_FILE_PATH\""

    echo "$PKG_PARAM:" >> "$EPM_DAT_FILE_PATH"
    echo "  $PKG_TYPE_KEY: $TYPE_PARAM" >> "$EPM_DAT_FILE_PATH"
    echo "  $PKG_OS_KEY: $OS_PARAM" >> "$EPM_DAT_FILE_PATH"
    echo "  $PKG_PARENT_KEY: $PARENT_PARAM" >> "$EPM_DAT_FILE_PATH"
    echo "  $PKG_DEPENDENCIES_KEY: $DEPENDENCIES_PARAM" >> "$EPM_DAT_FILE_PATH"
    echo "  $PKG_DESCRIPTION_KEY: $DESCRIPTION_PARAM" >> "$EPM_DAT_FILE_PATH"
}

data_pkg_remove() {
    sed -i "/$1:/","/[ ]*$PKG_DESCRIPTION_KEY/d" "$EPM_DAT_FILE_PATH"
}

data_pkg_list() {
    file_read "$EPM_DAT_FILE_PATH" | grep -Po "(?<=)^[a-zA-Z]{1}[_a-zA-Z0-9]+(?=:)"
}

data_pkg_get() {
    log_trace "Getting package \"$1\" info from \"$EPM_DAT_FILE_PATH\""
    file_read "$EPM_DAT_FILE_PATH" | parse_yaml | grep -Po "^$1:.*$"
}

data_pkg_exists() {
    log_trace "Checking if package \"$1\" is installed"
    ! empty "$(data_pkg_get "$1")"
}

data_pkg_get_prop() {
    data_pkg_get "$1" | prop_get "$1:$2"
}

data_pkg_set_prop() {
    awk -i inplace -F":" -v pkg="$1" -v prop="$2" -v val="$3" '
        match($1, prop) { 
            if ( cpkg == pkg ) {
                $2=" "val
            }
        }
        match($1, "^[a-zA-Z]{1}[a-zA-Z0-9_]*$") { cpkg=$1 }
        { print $1":"$2}
    ' "$EPM_DAT_FILE_PATH"
}

data_pkg_add_prop() {
    awk -i inplace -F":" -v pkg="$1" -v prop="$2" -v val="$3" '
        function ltrim(s) { sub(/^[ \t\r\n]+/, "", s); return s }
        function rtrim(s) { sub(/[ \t\r\n]+$/, "", s); return s }
        function trim(s) { return rtrim(ltrim(s)); }
        match($1, prop) { 
            if ( cpkg == pkg ) {
                cval=trim($2);
                if (length(cval)==0) {
                    $2=" "val
                } else {
                    $2=" "cval","val 
                }
            }
        }
        match($1, "^[a-zA-Z]{1}[a-zA-Z0-9_]*$") { cpkg=$1 }
        { print $1":"$2}
    ' "$EPM_DAT_FILE_PATH"
}

data_pkg_get_tenant() {
    data_pkg_get_prop "$1" "$PKG_TENANT_KEY" 
}

data_pkg_get_type() {
    data_pkg_get_prop "$1" "$PKG_TYPE_KEY" 
}

data_pkg_is_single() {
    local PKG_TYPE="$(data_pkg_get_type "$1")" 
    [ "$PKG_TYPE" == "$PKG_TYPE_SINGLE" ]
}

data_pkg_is_bundle() {
    local PKG_TYPE="$(data_pkg_get_type "$1")" 
    [ "$PKG_TYPE" == "$PKG_TYPE_BUNDLE" ]
}

data_pkg_set_type() {
    data_pkg_set_prop "$1" "$PKG_TYPE_KEY" "$2" 
}

data_pkg_get_os() {
    data_pkg_get_prop "$1" "$PKG_OS_KEY" 
}

data_pkg_set_os() {
    data_pkg_set_prop "$1" "$PKG_OS_KEY" "$2" 
}

data_pkg_get_parent() {
    data_pkg_get_prop "$1" "$PKG_PARENT_KEY" 
}

data_pkg_set_parent() {
    data_pkg_set_prop "$1" "$PKG_PARENT_KEY" "$2" 
}

data_pkg_get_dependencies() {
    data_pkg_get_prop "$1" "$PKG_DEPENDENCIES_KEY" 
}

data_pkg_add_dependencies() {
    data_pkg_add_prop "$1" "$PKG_DEPENDENCIES_KEY" "$2" 
}

data_pkg_set_dependencies() {
    data_pkg_set_prop "$1" "$PKG_DEPENDENCIES_KEY" "$2" 
}

data_pkg_get_description() {
    data_pkg_get_prop "$1" "$PKG_DESCRIPTION_KEY" 
}

data_pkg_set_description() {
    data_pkg_set_prop "$1" "$PKG_DESCRIPTION_KEY" "$2" 
}

data_pkg_get_dependents() {
    MODE="$2"
    MODE="${MODE:-$PKG_DEPENDENTS_MODE_ALL}"

    log_trace "Getting all package dependents from \"$1\" in \"$MODE\" mode"

    while read -r PKG; do
        if [ "$MODE" == "$PKG_DEPENDENTS_MODE_PARENT" ]; then
            local PARENT="$(data_pkg_get_parent "$PKG")"
            local TPARENT="$(trim "$PARENT")"

            if [[ "$TPARENT" == "$1" ]]; then
                printf "%s\n" "$PKG"
            fi        
        elif [ "$MODE" == "$PKG_DEPENDENTS_MODE_DEPENDENCIES" ]; then
            local DEPENDENCIES="$(data_pkg_get_dependencies "$PKG")"

            if csv_contains "$DEPENDENCIES" "$1"; then
                printf "%s\n" "$PKG"
            fi        
        elif [ "$MODE" == "$PKG_DEPENDENTS_MODE_ALL" ]; then
            local PARENT="$(data_pkg_get_parent "$PKG")"
            local TPARENT="$(trim "$PARENT")"
            local DEPENDENCIES="$(data_pkg_get_dependencies "$PKG")"

            if [[ "$TPARENT" == "$1" ]] || csv_contains "$DEPENDENCIES" "$1"; then
                printf "%s\n" "$PKG"
            fi        
        fi
    done <<< "$(data_pkg_list)"
}

env_options() {
    OPTION_ADD="\t--add\t\tadd a new variable: name value"
    OPTION_REMOVE="\t--remove\tremove a variable: name"
    OPTION_GET="\t--get\t\tget value: name"
    OPTION_SET="\t--set\t\tset value: name value"
    OPTION_LIST="\t--list\t\tlists all the variables"
    OPTIONS="$OPTION_ADD\n$OPTION_REMOVE\n$OPTION_GET\n$OPTION_SET\n$OPTION_LIST"

    printf "%b\n" "$OPTIONS"
}

env_add_check() {
    USAGE_CMD="env --add"
    USAGE_CMD_SYNOPSIS="<name> <value>"
    USAGE_CMD_DESCRIPTION=""
   
    log_debug "Checking env-add command preconditions"

    if empty "$1" || empty "$2"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name and a value"
    fi
}

env_add() {
    ENV_ADD_NAME="$1"
    ENV_ADD_VALUE="$2"    

    log_debug "Executing env-add command with \"$ENV_ADD_NAME\" and \"$ENV_ADD_VALUE\""

    env_add_check "$ENV_ADD_NAME" "$ENV_ADD_VALUE"

    if var_exists "$ENV_ADD_NAME"; then
        var_set "$ENV_ADD_NAME" "$ENV_ADD_VALUE"
    else
        var_add "$ENV_ADD_NAME" "$ENV_ADD_VALUE"
    fi
}

env_remove_check() {
    USAGE_CMD="env --remove"
    USAGE_CMD_SYNOPSIS="<name>"
    USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking env-remove command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

env_remove() {
    ENV_REMOVE_NAME="$1"

    log_debug "Executing env-remove command with \"$ENV_REMOVE_NAME\""

    env_remove_check "$ENV_REMOVE_NAME"

    if var_exists "$ENV_REMOVE_NAME"; then
        var_remove "$ENV_REMOVE_NAME"
    fi
}

env_get_check() {
    USAGE_CMD="env --get"
    USAGE_CMD_SYNOPSIS="<name>"
    USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking env-get command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi

    if ! var_exists "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Variable \"$1\" does not exists"
    fi
}

env_get() {
    ENV_GET_NAME="$1"

    log_debug "Executing env-get command with \"$ENV_GET_NAME\""

    env_get_check "$ENV_GET_NAME"

    var_get "$ENV_GET_NAME"
}

env_set_check() {
    USAGE_CMD="env --set"
    USAGE_CMD_SYNOPSIS="<name> <value>"
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking env-set command preconditions"
   
    if empty "$1" || empty "$2"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name and a value"
    fi
}

env_set() {
    CONFIG_SET_NAME="$1"
    CONFIG_SET_VALUE="$2"

    log_debug "Executing env-set command with \"$CONFIG_SET_NAME\" and \"$CONFIG_SET_NAME\""

    env_set_check "$CONFIG_SET_NAME" "$CONFIG_SET_VALUE"

    if var_exists "$CONFIG_SET_NAME"; then
        var_set "$CONFIG_SET_NAME" "$CONFIG_SET_VALUE"
    else
        var_add "$CONFIG_SET_NAME" "$CONFIG_SET_VALUE"
    fi
}

env_default_check() {
    USAGE_CMD="env"
    USAGE_CMD_SYNOPSIS="<name> [value]"
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking env-default command preconditions"
    
    if empty $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

env_default() {
    CONFIG_DEFAULT_NAME="$1"
    CONFIG_DEFAULT_VALUE="$2"   
    
    log_debug "Executing the env-default command with \"$CONFIG_DEFAULT_NAME\" and \"$CONFIG_DEFAULT_VALUE\""

    env_default_check "$CONFIG_DEFAULT_NAME" "$CONFIG_DEFAULT_VALUE"

    if empty "$CONFIG_DEFAULT_VALUE"; then
        var_get "$CONFIG_DEFAULT_NAME"
    elif var_exists "$CONFIG_DEFAULT_NAME"; then
        var_set "$CONFIG_DEFAULT_NAME" "$CONFIG_DEFAULT_VALUE"
    else        
        var_add "$CONFIG_DEFAULT_NAME" "$CONFIG_DEFAULT_VALUE"
    fi
}

env_list_check() {
    USAGE_CMD="env --list"
    USAGE_CMD_SYNOPSIS=""
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking env-list command preconditions"
}

env_list() {
    log_debug "Executing the env-list command"

    env_list_check

    var_list | print_table2 "Variable" "Value"
}

env_check() {
    USAGE_CMD="env"
    USAGE_CMD_SYNOPSIS="[name] <value> | [option]"
    USAGE_CMD_DESCRIPTION="\nOptions:\n$(env_options)"

    check

    log_debug "Checking $USAGE_CMD command preconditions"
    
    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name or an option"
    fi
}

env() {
    log_debug "Executing the env command with \"$1\""

    env_check "$1" 
    
    case "$1" in
        --add)
            env_add "$2" "$3"
            ;;
        --remove)
            env_remove "$2"
            ;;
        --get)
            env_get "$2"
            ;;
        --set)
            env_set "$2" "$3"
            ;;                
        --list)
            env_list
            ;;
        *)
            env_default "$1" "$2"
            ;;
    esac
}

lib_options() {
    OPTION_ADD="\t--add\t\tadd a new library: path"
    OPTION_REMOVE="\t--remove\tremove a library: name"
    OPTION_LIST="\t--list\t\tlists all the libraries"
    OPTIONS="$OPTION_ADD\n$OPTION_REMOVE\n$OPTION_LIST"

    printf "%b\n" "$OPTIONS"
}

lib_add_check() {
    USAGE_CMD="lib --add"
    USAGE_CMD_SYNOPSIS="<path>"
    USAGE_CMD_DESCRIPTION=""
   
    log_debug "Checking lib-add command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a path"
    elif ! file_exists "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify an existing file"
    fi
}

lib_add_exec() {
    LIB_ADD_PATH="$1"
    LIB_ADD_FILE_NAME="$(basename -- "$LIB_ADD_PATH")"
    LIB_ADD_NAME="${LIB_ADD_FILE_NAME%.*}"
    LIB_ADD_NEW_PATH="$EPM_LIB_PATH/${LIB_ADD_NAME}.sh"
    LIB_ADD_BCK_PATH="${LIB_ADD_NEW_PATH}.bak"

    if file_exists "$LIB_ADD_NEW_PATH"; then
        file_move "$LIB_ADD_NEW_PATH" "$LIB_ADD_BCK_PATH"
    fi

    log_trace "Copying library from \"$LIB_ADD_PATH\" to \"$LIB_ADD_NEW_PATH\""
    file_copy "$LIB_ADD_PATH" "$LIB_ADD_NEW_PATH"
    file_executable "$LIB_ADD_NEW_PATH"

    log_trace "Adding library path \"$LIB_ADD_NEW_PATH\" to \"$EPM_LIB_FILE_PATH\""
    printf "source \"%s\"\n" "$LIB_ADD_NEW_PATH" >> "$EPM_LIB_FILE_PATH" 
}

lib_add() {
    log_debug "Executing lib-add command with \"$1\""

    lib_add_check "$1"

    lib_add_exec "$1"
}

lib_remove_check() {
    USAGE_CMD="lib --remove"
    USAGE_CMD_SYNOPSIS="<name>"
    USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking lib-remove command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a library"
    elif ! file_exists "$EPM_LIB_PATH/$1.sh"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "The library \"$1\" does not exist"
    fi
}

lib_remove_exec() {
    LIB_REMOVE_NAME="$1"
    LIB_REMOVE_PATH="$EPM_LIB_PATH/$1.sh"

    log_trace "Removing library from \"$LIB_REMOVE_PATH\""
    rm -f "$LIB_REMOVE_PATH"

    log_trace "Removing library path \"$LIB_REMOVE_PATH\" from \"$EPM_LIB_FILE_PATH\""
    sed -i "\|source \"$LIB_REMOVE_PATH\"|d" "$EPM_LIB_FILE_PATH"
}

lib_remove() {
    log_debug "Executing lib-remove command with \"$1\""

    lib_remove_check "$1"

    lib_remove_exec "$1"
}

lib_list_check() {
    USAGE_CMD="list --list"
    USAGE_CMD_SYNOPSIS=""
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking lib-list command preconditions"
}

lib_list_exec() {
    while read -r LIB_FILE_NAME; do
        echo "${LIB_FILE_NAME%.*}"
    done <<< "$(file_list "$EPM_LIB_PATH")"
}

lib_list() {
    log_debug "Executing the lib-list command"

    lib_list_check

    lib_list_exec | print_table1 "Library"
}

lib_check() {
    USAGE_CMD="lib"
    USAGE_CMD_SYNOPSIS="<option> [path]"
    USAGE_CMD_DESCRIPTION="\nOptions:\n$(lib_options)"

    check

    log_debug "Checking lib command preconditions"
    
    case "$1" in
        "--add")
            ;;
        "--remove")
            ;;
        ""|"--list")
            ;;
        *)
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid option"
            ;;
    esac
}

lib() {
    log_debug "Executing the lib command with \"$1\""

    lib_check "$1"
    
    case "$1" in
        "--add")
            lib_add "$2"
            ;;
        "--remove")
            lib_remove "$2"
            ;;
        ""|"--list")
            lib_list
            ;;
    esac
}

init_check() {
    USAGE_CMD="init"
    USAGE_CMD_SYNOPSIS="<repo>"
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking init command preconditions"

    if empty $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a repository to use"
    fi

    if ! url_valid $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a valid url"
    fi

    if file_exists $EPM_ENV_FILE_PATH; then
        yesNo "${PROGRAM_NAME} already initialized, overwrite? "
    fi
}

init_env() {
    var_add "$PROGRAM_PATH_KEY" "$PROGRAM_PATH"
    var_add "$ROOT_PATH_KEY" "$ROOT_PATH"
    var_add "$BIN_PATH_KEY" "$BIN_PATH"
    var_add "$LIB_PATH_KEY" "$LIB_PATH"
    var_add "$ETC_PATH_KEY" "$ETC_PATH"
    var_add "$VAR_PATH_KEY" "$VAR_PATH"
    var_add "$LOG_PATH_KEY" "$LOG_PATH"
    var_add "$TMP_PATH_KEY" "$TMP_PATH"
    var_add "$APP_PATH_KEY" "$APP_PATH"
    var_add "$WS_PATH_KEY" "$WS_PATH"
    var_add "$WWW_PATH_KEY" "$WWW_PATH"
    var_add "$EPM_CFG_PATH_KEY" "$EPM_CFG_PATH"
    var_add "$EPM_BIN_PATH_KEY" "$EPM_BIN_PATH"
    var_add "$EPM_LIB_PATH_KEY" "$EPM_LIB_PATH"
    var_add "$EPM_PKG_PATH_KEY" "$EPM_PKG_PATH"
    var_add "$EPM_STG_PATH_KEY" "$EPM_STG_PATH"
    var_add "$EPM_PKG_SRV_KEY" "$INIT_URL"
    var_add "$EPM_LOG_PATH_KEY" "$EPM_LOG_PATH"
}

init_lib() {
    printf "#!/usr/bin/env bash\n\n" >> "$EPM_LIB_FILE_PATH" 
    printf "env_add() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s env --add \"%s\" \"%s\"\n" '$PROGRAM_PATH' '$1' '$2' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "env_remove() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s env --remove \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "lib_add() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s lib --add \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "lib_remove() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s lib --remove \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "metadata_get() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s metadata \"%s\" --get \"%s\" \"%s\"\n" '$PROGRAM_PATH' '$1' '$2' '$3' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "config_get() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s config \"%s\" --get \"%s\" \"%s\"\n" '$PROGRAM_PATH' '$1' '$2' '$3' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "pack_begin() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\tlocal SCRIPT_LOG_PATH=\"%s/pack_%s.log\"\n\n" '$EPM_LOG_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "\texec 3>&1 4>&2 1>\"%s\" 2>&1\n" '$SCRIPT_LOG_PATH' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "pack_end() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\texec 1>&3 2>&4\n" >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "require() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s require \"%s\" \"%s\" \"%s\"\n" '$PROGRAM_PATH' '$1' '$2' '$3' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "install() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s install \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "install_begin() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\tlocal SCRIPT_LOG_PATH=\"%s/install_%s.log\"\n\n" '$EPM_LOG_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "\t%s status --install-begin \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "\texec 3>&1 4>&2 1>\"%s\" 2>&1\n" '$SCRIPT_LOG_PATH' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "install_end() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\texec 1>&3 2>&4\n" >> "$EPM_LIB_FILE_PATH" 
    printf "\t%s status --install-end \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "uninstall() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\t%s uninstall \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "uninstall_begin() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\tlocal SCRIPT_LOG_PATH=\"%s/uninstall_%s.log\"\n\n" '$EPM_LOG_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "\t%s status --uninstall-begin \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "\texec 3>&1 4>&2 1>\"%s\" 2>&1\n" '$SCRIPT_LOG_PATH' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "uninstall_end() {\n" >> "$EPM_LIB_FILE_PATH"
    printf "\texec 1>&3 2>&4\n" >> "$EPM_LIB_FILE_PATH" 
    printf "\t%s status --uninstall-end \"%s\"\n" '$PROGRAM_PATH' '$1' >> "$EPM_LIB_FILE_PATH" 
    printf "}\n\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f env_add\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f env_remove\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f lib_add\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f lib_remove\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f metadata_get\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f config_get\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f pack_begin\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f pack_end\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f require\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f install\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f install_begin\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f install_end\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f uninstall\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f uninstall_begin\n" >> "$EPM_LIB_FILE_PATH"
    printf "export -f uninstall_end\n" >> "$EPM_LIB_FILE_PATH"
}

init_exec() {
    INIT_URL="$1"

    if dir_exists "$EPM_PATH"; then
        if file_exists "$EPM_LOG_FILE_PATH"; then
            file_truncate "$EPM_LOG_FILE_PATH"
        else
            file_create "$EPM_LOG_FILE_PATH"
        fi

        if file_exists "$EPM_ENV_FILE_PATH"; then
            file_truncate "$EPM_ENV_FILE_PATH"
        else
            file_create "$EPM_ENV_FILE_PATH"
            file_executable "$EPM_ENV_FILE_PATH"    
        fi

        if file_exists "$EPM_LIB_FILE_PATH"; then
            file_truncate "$EPM_LIB_FILE_PATH"
        else
            file_create "$EPM_LIB_FILE_PATH"
            file_executable "$EPM_LIB_FILE_PATH"    
        fi

        if file_exists "$EPM_DAT_FILE_PATH"; then
            file_truncate "$EPM_DAT_FILE_PATH"
        else
            file_create "$EPM_DAT_FILE_PATH"
        fi
    else
        dir_create "$EPM_PATH"
        dir_create "$EPM_LIB_PATH"
        dir_create "$EPM_LOG_PATH"
        file_create "$EPM_ENV_FILE_PATH"
        file_executable "$EPM_ENV_FILE_PATH"    
        file_create "$EPM_LIB_FILE_PATH"
        file_executable "$EPM_LIB_FILE_PATH"    
        file_create "$EPM_LOG_FILE_PATH"
        file_create "$EPM_DAT_FILE_PATH"
    fi

    ! dir_exists "$BIN_PATH" && dir_create "$BIN_PATH"
    ! dir_exists "$LIB_PATH" && dir_create "$LIB_PATH"
    ! dir_exists "$ETC_PATH" && dir_create "$ETC_PATH"
    ! dir_exists "$VAR_PATH" && dir_create "$VAR_PATH"
    ! dir_exists "$LOG_PATH" && dir_create "$LOG_PATH"
    ! dir_exists "$EPM_LOG_PATH" && dir_create "$EPM_LOG_PATH"
    ! dir_exists "$TMP_PATH" && dir_create "$TMP_PATH"
    ! dir_exists "$APP_PATH" && dir_create "$APP_PATH"
    ! dir_exists "$WS_PATH" && dir_create "$WS_PATH"
    ! dir_exists "$WWW_PATH" && dir_create "$WWW_PATH"
    ! dir_exists "$EPM_CFG_PATH" && dir_create "$EPM_CFG_PATH"
    ! dir_exists "$EPM_BIN_PATH" && dir_create "$EPM_BIN_PATH"
    ! dir_exists "$EPM_LIB_PATH" && dir_create "$EPM_LIB_PATH"
    ! dir_exists "$EPM_PKG_PATH" && dir_create "$EPM_PKG_PATH"
    ! dir_exists "$EPM_STG_PATH" && dir_create "$EPM_STG_PATH"

    init_env
    init_lib
}

init_begin() {
    command_begin "Initializing $PROGRAM_NAME"
}

init() {
    log_debug "Executing the init command with \"$1\""

    init_check "$1"

    init_begin

    init_exec "$1"

    command_ok
}

pull_check() {
    local USAGE_CMD="pull"
    local USAGE_CMD_SYNOPSIS="<package>"
    local USAGE_CMD_DESCRIPTION=""
 
    check

    log_debug "Checking pull command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package to pull"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    fi
}

pull_exec() {
    local PULL_PACKAGE="$1"
    local PKG_PATH="$EPM_PKG_PATH/$PULL_PACKAGE"
    local EPM_PKG_SRV="$(var_get $EPM_PKG_SRV_KEY)"
    local PKG_SRV_PATH="$EPM_PKG_SRV"

    if ! dir_exists "$PKG_PATH"; then
        log_debug "Package directory does not exist, now checking staging directory"
        YML_FILE_ALL="$PULL_PACKAGE-$OS_ALL.$YML_EXT"
        PKG_FILE_ALL="$PULL_PACKAGE-$OS_ALL.$PKG_EXT"
        YML_FILE_NIX="$PULL_PACKAGE-$OS_NIX.$YML_EXT"
        PKG_FILE_NIX="$PULL_PACKAGE-$OS_NIX.$PKG_EXT"
        PKG_STG_PATH="$EPM_STG_PATH"

        if file_exists "$PKG_STG_PATH/$YML_FILE_ALL" && file_exists "$PKG_STG_PATH/$PKG_FILE_ALL"; then
            log_debug "Package for all exists in staging directory"
            YML_STG_FILE_PATH="$PKG_STG_PATH/$YML_FILE_ALL"
            PKG_STG_FILE_PATH="$PKG_STG_PATH/$PKG_FILE_ALL"
            PKG_OS_PATH="$PKG_PATH/$OS_ALL"
        elif file_exists "$PKG_STG_PATH/$YML_FILE_NIX" && file_exists "$PKG_STG_PATH/$PKG_FILE_NIX"; then
            log_debug "Package for nix exists in staging directory"
            YML_STG_FILE_PATH="$PKG_STG_PATH/$YML_FILE_NIX"
            PKG_STG_FILE_PATH="$PKG_STG_PATH/$PKG_FILE_NIX"
            PKG_OS_PATH="$PKG_PATH/$OS_NIX"
        else
            log_debug "Package does not exist in the staging directory, trying to fetch it from the server"
            YML_SRV_ALL="$EPM_PKG_SRV/$YML_FILE_ALL"
            PKG_SRV_ALL="$EPM_PKG_SRV/$PKG_FILE_ALL"
            YML_SRV_NIX="$EPM_PKG_SRV/$YML_FILE_NIX"
            PKG_SRV_NIX="$EPM_PKG_SRV/$PKG_FILE_NIX"

            if url_file_exists "$YML_SRV_ALL" && url_file_exists "$PKG_SRV_ALL"; then
                log_debug "Package for all exists in the server"
                YML_STG_FILE_PATH="$PKG_STG_PATH/$YML_FILE_ALL"
                PKG_STG_FILE_PATH="$PKG_STG_PATH/$PKG_FILE_ALL"
                YML_URL="$YML_SRV_ALL"
                PKG_URL="$PKG_SRV_ALL"
                PKG_OS_PATH="$PKG_PATH/$OS_ALL"
            elif url_file_exists "$YML_SRV_NIX" && url_file_exists "$PKG_SRV_NIX"; then
                log_debug "Package for nix exists in the server"
                YML_STG_FILE_PATH="$PKG_STG_PATH/$YML_FILE_NIX"
                PKG_STG_FILE_PATH="$PKG_STG_PATH/$PKG_FILE_NIX"
                YML_URL="$YML_SRV_NIX"
                PKG_URL="$PKG_SRV_NIX"
                PKG_OS_PATH="$PKG_PATH/$OS_NIX"
            else
                command_fail "Package \"$PULL_PACKAGE\" does not exist at \"$EPM_PKG_SRV\""
            fi
            
            dir_create "$PKG_STG_PATH"
            download_step
            if ! url_file_download "$YML_STG_FILE_PATH" "$YML_URL" || ! url_file_download "$PKG_STG_FILE_PATH" "$PKG_URL"; then
                file_delete "$YML_STG_FILE_PATH"
                file_delete "$PKG_STG_FILE_PATH"
                command_fail "Unable to download package \"$PULL_PACKAGE\" to \"$PKG_STG_PATH\""
            fi
            running_step
        fi

        dir_create "$PKG_OS_PATH"
        archive_extract "$PKG_STG_FILE_PATH" "$PKG_OS_PATH"
        file_delete "$PKG_STG_FILE_PATH"
        file_move "$YML_STG_FILE_PATH" "$PKG_PATH"
    fi
}

pull_begin() {
    command_begin "Pulling package $1"
}

pull_package_exec() {
    pull_begin "$1"

    pull_exec "$1"

    command_ok
}

pull_package() {
    pull_package_exec "$1"
}

pull() {
    log_debug "Executing the pull command with \"$1\""

    pull_check "$1"

    pull_package "$1"
}

uninstall_exec() {
    UNINSTALL_PACKAGE="$1"
    PKG_PATH="$EPM_PKG_PATH/$UNINSTALL_PACKAGE"

    PKG_OS="$(pkg_os "$UNINSTALL_PACKAGE")"
    PKG_OS_PATH="$PKG_PATH/$PKG_OS"
    PKG_UNINSTALL_SH_PATH="$PKG_OS_PATH/$PKG_UNINSTALL_FILE_NAME"

    log_debug "Loading $PROGRAM_NAME environment located at \"$EPM_ENV_FILE_PATH\""
    source "$EPM_ENV_FILE_PATH"
    log_debug "Loading $PROGRAM_NAME libraries located at \"$EPM_LIB_FILE_PATH\""
    source "$EPM_LIB_FILE_PATH"

    if $PKG_UNINSTALL_SH_PATH; then
        data_pkg_remove "$UNINSTALL_PACKAGE"
    else
        command_fail
    fi
}

get_uninstall_dependencies() {
    PKG_IN_LIST=("$1")
    declare -A PKG_OUT_LIST

    PKG_CURRENT=""
    PKG_LEVEL=0
    while [ ${#PKG_IN_LIST[@]} -gt 0 ]; do
        PKG_CURRENT="${PKG_IN_LIST[0]}"
        if data_pkg_exists "$PKG_CURRENT"; then
            PKG_OUT_LIST["$PKG_CURRENT"]=$PKG_LEVEL
            
            while read -r PKG; do
                if ! empty "$PKG" && data_pkg_exists "$PKG"; then
                    PKG_IN_LIST+=("$PKG")
                fi
            done <<< "$(data_pkg_get_dependents "$PKG_CURRENT")"
        fi

        (( PKG_LEVEL++ ))
        PKG_IN_LIST=("${PKG_IN_LIST[@]:1}")
    done
    
    for KEY in "${!PKG_OUT_LIST[@]}"; do
        echo ${PKG_OUT_LIST["$KEY"]} "$KEY"
    done | sort -rn -k1 | cut -f2 -d' '
}

uninstall_check() {
    USAGE_CMD="uninstall"
    USAGE_CMD_SYNOPSIS="<package>"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking uninstall command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package to uninstall"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    fi

    if ! data_pkg_exists "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Package \"$1\" is not installed"
    fi
}

uninstall_begin() {
    command_begin "Uninstalling package $1"
}

uninstall_end() {
    command_ok
}

uninstall_package_exec() {
    uninstall_exec "$1"
}

uninstall_package() {
    while read -r PKG; do
        local PKG_TYPE="$(pkg_metadata_get_type "$PKG")"
        
        if [ "$PKG" == "$1" ]; then
            uninstall_package_exec "$PKG"
        else
            if data_pkg_is_single "$PKG"; then
                uninstall_package_exec "$PKG"
            elif data_pkg_is_bundle "$PKG"; then
                data_pkg_remove "$PKG" 
            fi
        fi
    done <<< "$(get_uninstall_dependencies "$1")"
}

uninstall() {
    log_debug "Executing the uninstall command with \"$1\""

    uninstall_check "$1"

    uninstall_package "$1"
}

purge_check() {
    USAGE_CMD="purge"
    USAGE_CMD_SYNOPSIS="<package>"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking purge command preconditions"

    if empty $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package to purge"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    fi

    if ! data_pkg_exists "$1" && ! dir_exists "$EPM_PKG_PATH/$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Package \"$1\" does not exist"
    fi
}

purge_exec() {
    PURGE_PACKAGE="$1"

    PKG_PATH="$EPM_PKG_PATH/$PURGE_PACKAGE"
    if dir_exists "$PKG_PATH"; then
        dir_delete "$PKG_PATH" 
    fi
}

purge_begin() {
    command_begin "Purging package $1"
}

purge_package_exec() {
    purge_begin "$1"

    purge_exec "$1"

    command_ok
}

purge_package() {
    uninstall_package "$1"   

    purge_package_exec "$1"
}

purge() {
    log_debug "Executing the purge command with \"$1\""

    purge_check "$1"
    
    purge_package "$1"
}

install_exec() {
    INSTALL_PACKAGE=$1
    PKG_PATH="$EPM_PKG_PATH/$INSTALL_PACKAGE"

    pull_exec "$INSTALL_PACKAGE"
    PKG_OS="$(pkg_os "$INSTALL_PACKAGE")"
    PKG_OS_PATH="$PKG_PATH/$PKG_OS"
    PKG_TYPE="$(pkg_metadata_get_type "$INSTALL_PACKAGE")"
    PKG_PARENT="$(pkg_metadata_get_parent "$INSTALL_PACKAGE")"
    PKG_DEPENDENCIES="$(pkg_metadata_get_dependencies "$INSTALL_PACKAGE")"
    PKG_DESCRIPTION="$(pkg_metadata_get_description "$INSTALL_PACKAGE")"
    PKG_INSTALL_SH_PATH="$PKG_OS_PATH/$PKG_INSTALL_FILE_NAME"

    log_debug "Loading $PROGRAM_NAME environment located at \"$EPM_ENV_FILE_PATH\""
    source "$EPM_ENV_FILE_PATH" 
    log_debug "Loading $PROGRAM_NAME libraries located at \"$EPM_LIB_FILE_PATH\""
    source "$EPM_LIB_FILE_PATH"

    data_pkg_add "$INSTALL_PACKAGE"\
        "$PKG_TYPE"\
        "$PKG_OS"\
        "$PKG_PARENT"\
        "$PKG_DEPENDENCIES"\
        "$PKG_DESCRIPTION"
    
    log_debug "Executing \"$PKG_TYPE\" install script"
    if ! $PKG_INSTALL_SH_PATH; then
        log_debug "Installation of package \"$INSTALL_PACKAGE\" failed"
        data_pkg_remove "$INSTALL_PACKAGE"             
        command_fail
    fi
}

get_install_dependencies() {
    PKG_IN_LIST=("$1")
    declare -A PKG_OUT_LIST

    PKG_CURRENT=""
    PKG_LEVEL=0
    while [ ${#PKG_IN_LIST[@]} -gt 0 ]; do
        PKG_CURRENT="${PKG_IN_LIST[0]}"
        
        if ! data_pkg_exists "$PKG_CURRENT"; then
            PKG_OUT_LIST["$PKG_CURRENT"]=$PKG_LEVEL
            PKG_PARENT=$(pkg_metadata_get_parent "$PKG_CURRENT")
            if ! empty "$PKG_PARENT"; then
                PKG_IN_LIST+=("$PKG_PARENT")
            fi
            while IFS=',' read -ra DEPS; do
                for DEP in "${DEPS[@]}"; do
                    PKG_IN_LIST+=("$DEP")
                done
            done <<< $(pkg_metadata_get_dependencies "$PKG_CURRENT")
        fi

        (( PKG_LEVEL++ ))
        PKG_IN_LIST=("${PKG_IN_LIST[@]:1}")
    done

    for KEY in "${!PKG_OUT_LIST[@]}"; do
        echo ${PKG_OUT_LIST["$KEY"]} "$KEY"
    done | sort -rn -k1 | cut -f2 -d' '
}

install_check() {
    USAGE_CMD="install"
    USAGE_CMD_SYNOPSIS="<package>"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking install command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package to install"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    fi

    if data_pkg_exists "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Package \"$1\" is already installed"
    fi
}

install_begin() {
    command_begin "Installing package $1"
}

install_end() {
    command_ok
}

install_package_exec() {
    install_exec "$1"
}

install_package() {
    while read -r PKG; do
        install_package_exec "$PKG"
    done <<< "$(get_install_dependencies "$1")"
}

install() {
    log_debug "Executing the install command with \"$1\""

    install_check "$1"

    install_package "$1"
}

require_check() {
    USAGE_CMD="require"
    USAGE_CMD_SYNOPSIS="<package>|<package> <target>|<package> <-p|--parent|-d|--dependecy> <target>"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking require command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    fi

    if ! empty "$2"; then
        case "$2" in
            "-p"|"--parent"|"-d"|"--dependency")
                if empty "$3"; then
                    command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the target package"
                elif ! is_package "$3"; then
                    command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid target package name: \"$3\""
                fi
                ;;
            *)
                if ! is_package "$2"; then
                    command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid target package name: \"$2\""
                fi
                ;;
        esac
    fi
}

require() {
    local REQUIRE_SOURCE_PKG="${1:-}"
    local REQUIRE_TARGET_TYPE="${2:-}"
    local REQUIRE_TARGET_PKG="${3:-}"

    log_debug "Executing the require command with \"$REQUIRE_SOURCE_PKG\", \"$REQUIRE_TARGET_TYPE\" and \"$REQUIRE_TARGET_PKG\""

    require_check "$REQUIRE_SOURCE_PKG" "$REQUIRE_TARGET_TYPE" "$REQUIRE_TARGET_PKG"

    local REQUIRE_PKG="${3:-"$2"}"
    REQUIRE_PKG="${REQUIRE_PKG:-"$1"}"
    if ! data_pkg_exists "$REQUIRE_PKG"; then
        log_debug "Package \"$REQUIRE_PKG\" is not installed proceding with the installation"

        install_package "$REQUIRE_PKG"

        if ! empty "$REQUIRE_TARGET_TYPE"; then
            case "$REQUIRE_TARGET_TYPE" in
                "-p"|"--parent")
                    log_debug "Setting parent \"$REQUIRE_PKG\" in \"$REQUIRE_SOURCE_PKG\""

                    data_pkg_set_parent "$REQUIRE_SOURCE_PKG" "$REQUIRE_PKG"
                    ;;
                ""|"-d"|"--dependency")
                    log_debug "Adding dependency \"$REQUIRE_PKG\" to \"$REQUIRE_SOURCE_PKG\""

                    data_pkg_add_dependencies "$REQUIRE_SOURCE_PKG" "$REQUIRE_PKG"
                    ;;
            esac
        fi
    else
        if ! empty "$REQUIRE_TARGET_TYPE"; then
            case "$REQUIRE_TARGET_TYPE" in
                "-p"|"--parent")
                    log_debug "Package \"$REQUIRE_PKG\" is installed setting parent"

                    data_pkg_set_parent "$REQUIRE_SOURCE_PKG" "$REQUIRE_PKG"
                    ;;
                ""|"-d"|"--dependency")
                    log_debug "Package \"$REQUIRE_PKG\" is installed checking dependencies"

                    local REQUIRE_PKG_DEPENDENCIES="$(pkg_metadata_get_dependencies "$REQUIRE_SOURCE_PKG")"
                    if [[ $REQUIRE_PKG_DEPENDENCIES == *$REQUIRE_PKG* ]]; then
                        log_debug "Dependency \"$REQUIRE_PKG\" is on package "\"$REQUIRE_SOURCE_PKG\"" dependencies"
                    else
                        log_debug "Dependency \"$REQUIRE_PKG\" is not package "\"$REQUIRE_SOURCE_PKG\"" dependencies, adding it"

                        data_pkg_add_dependencies "$REQUIRE_SOURCE_PKG" "$REQUIRE_PKG"
                    fi
                    ;;
            esac
        else
            log_debug "Package \"$REQUIRE_PKG\" is aleady installed"
        fi
    fi
}

pack_build() {
    PKG="$1"
    PKG_OS="$(pkg_os "$PKG")"

    PKG_SRC_PATH="$EPM_PKG_PATH/$PKG/$PKG_OS"
    PKG_PACK_FILE_PATH="$PKG_SRC_PATH/$PKG_PACK_FILE_NAME"
    PKG_FILE_NAME="$PKG-$PKG_OS.$PKG_EXT"
    PKG_FILE_PATH="$EPM_STG_PATH/$PKG_FILE_NAME"
    YML_FILE_NAME="$PKG-$PKG_OS.$YML_EXT"
    YML_FILE_PATH="$EPM_STG_PATH/$YML_FILE_NAME"

    if file_exists "$PKG_PACK_FILE_PATH"; then
        log_debug "Executing package \"$PKG\" custom pack script"
        if ! "$PKG_PACK_FILE_PATH"; then
            command_fail
        fi
    fi
    
    local PKG_SHA1="$(dir_checksum "$PKG_SRC_PATH")"
    local PKG_TIMESTAMP="$(get_timestamp)"
    local PKG_TENANT="$(pkg_metadata_get_tenant "$PKG")"
    local PKG_TYPE="$(pkg_metadata_get_type "$PKG")"
    local PKG_PARENT="$(pkg_metadata_get_parent "$PKG")"
    local PKG_DEPENDENCIES="$(pkg_metadata_get_dependencies "$PKG")"
    local PKG_DESCRIPTION="$(pkg_metadata_get_description "$PKG")"

    archive_create "$PKG_FILE_PATH" "$PKG_SRC_PATH"
    
    if file_exists "$YML_FILE_PATH"; then
        file_truncate "$YML_FILE_PATH"
    else
        file_create "$YML_FILE_PATH"
    fi
    
    pkg_metadata_new "$PKG" \
        "$PKG_SHA1"\
        "$PKG_TIMESTAMP"\
        "$PKG_TENANT"\
        "$PKG_TYPE"\
        "$PKG_PARENT"\
        "$PKG_DEPENDENCIES"\
        "$PKG_DESCRIPTION"\
        "$YML_FILE_PATH"
}

pack_exec() {
    PACK_PKG="$1"

    log_debug "Loading $PROGRAM_NAME environment located at \"$EPM_ENV_FILE_PATH\""
    source "$EPM_ENV_FILE_PATH"
    source "$EPM_LIB_FILE_PATH"
    pack_build "$PACK_PKG"
}

pack_check() {
    USAGE_CMD="pack"
    USAGE_CMD_SYNOPSIS="<package>"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking pack command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package to pack"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    fi

    PKG_PATH="$EPM_PKG_PATH/$1"
    if ! dir_exists "$PKG_PATH"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Package $1 does not exist"
    fi
}

pack_begin() {
    command_begin "Packing package $1"
}

pack() {
    log_debug "Executing the pack command with \"$1\""

    pack_check "$1"
    
    pack_begin "$1"
    
    pack_exec "$1"
    
    command_ok
}

push_exec() {
    PUSH_PACKAGE="$1"
    PUSH_OS="$(pkg_os "$PUSH_PACKAGE")"
    PKG_PATH="$EPM_PKG_PATH/$PUSH_PACKAGE"
    EPM_PKG_SRV="$(var_get "$EPM_PKG_SRV_KEY")"

    log_debug "Pushing package \"$PUSH_PACKAGE\""

    YML_FILE_NAME="$PUSH_PACKAGE-$PUSH_OS.$YML_EXT"
    YML_FILE_PATH="$EPM_STG_PATH/$YML_FILE_NAME"
    YML_FILE_URL="$EPM_PKG_SRV/$YML_FILE_NAME"
    PKG_FILE_NAME="$PUSH_PACKAGE-$PUSH_OS.$PKG_EXT"
    PKG_FILE_PATH="$EPM_STG_PATH/$PKG_FILE_NAME"
    PKG_FILE_URL="$EPM_PKG_SRV/$PKG_FILE_NAME"

    url_file_upload "$YML_FILE_PATH" "$YML_FILE_URL"
    file_move "$YML_FILE_PATH" "$PKG_PATH"
    url_file_upload "$PKG_FILE_PATH" "$PKG_FILE_URL"
    file_delete "$PKG_FILE_PATH"
}

push_check() {
    USAGE_CMD="push"
    USAGE_CMD_SYNOPSIS="<package>|--all"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking push command preconditions"

    case $1 in
        --all)
            ;;
        --*)
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid option: $1"
            ;;
        "")
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package to push or an option"
            ;;                
        *)
            PKG_PATH="$EPM_PKG_PATH/$1"
            if ! is_package "$1"; then
                command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
            elif ! dir_exists $PKG_PATH; then
                command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Package \"$1\" does not exist"
            fi
    esac
}

push_begin() {
    command_begin "Pushing package $1"
}

push() {
    log_debug "executing the push command with \"$1\""

    push_check "$1"

    case "$1" in
        --all)
            log_debug "Pushing all packages"
            PKG_LIST=$EPM_PKG_PATH/*
            ;;
        *)
            log_debug "Pushing \"$1\" package"
            PKG_LIST=$EPM_PKG_PATH/$1
            ;;
    esac

    for PKG_PATH in $PKG_LIST; do
        PKG_NAME="$(basename $PKG_PATH)"

        push_begin "$PKG_NAME"

        pack_exec "$PKG_NAME"
        push_exec "$PKG_NAME"

        command_ok
    done
}

get_update_dependencies() {
    PKG_IN_LIST=("$1")
    declare -A PKG_OUT_LIST

    PKG_CURRENT=""
    PKG_LEVEL=0
    while [ ${#PKG_IN_LIST[@]} -gt 0 ]; do
        PKG_CURRENT="${PKG_IN_LIST[0]}"
        PKG_OUT_LIST["$PKG_CURRENT"]=$PKG_LEVEL
        if data_pkg_exists "$PKG_CURRENT"; then
            while read -r PKG; do
                if ! empty "$PKG" && data_pkg_exists "$PKG"; then
                    PKG_IN_LIST+=("$PKG")
                fi
            done <<< "$(data_pkg_get_dependents "$PKG_CURRENT" "$PKG_DEPENDENTS_MODE_PARENT")"
        fi
        
        (( PKG_LEVEL++ ))
        PKG_IN_LIST=("${PKG_IN_LIST[@]:1}")
    done

    for KEY in "${!PKG_OUT_LIST[@]}"; do
        echo ${PKG_OUT_LIST["$KEY"]} "$KEY"
    done | sort -rn -k1 | cut -f2 -d' '
}

package_updated() {
    PKG="$1"
    PKG_OS="$(pkg_os "$PKG")"
    EPM_PKG_SRV="$(var_get "$EPM_PKG_SRV_KEY")"
    YML_FILE_NAME="$PKG-$PKG_OS.$YML_EXT"
    YML_FILE_PATH="$EPM_PKG_PATH/$PKG/$YML_FILE_NAME"
    YML_URL="$EPM_PKG_SRV/$YML_FILE_NAME"

    LOCAL_SHA1=$(pkg_metadata_get_sha1 "$PKG" "$PKG_METADATA_SOURCE_LOCAL")
    REMOTE_SHA1=$(pkg_metadata_get_sha1 "$PKG" "$PKG_METADATA_SOURCE_REMOTE")

    if [ "$LOCAL_SHA1" != "$REMOTE_SHA1" ]; then
        log_trace "\"$PKG\" hash ($LOCAL_SHA1) is different from remote hash ($REMOTE_SHA1)"
        return 0
    fi
    
    log_trace "\"$PKG\" hash ($LOCAL_SHA1) is equal to remote hash ($REMOTE_SHA1)"

    return 1
}

get_updated_packages() {
    if ! empty "$1"; then
        log_trace "Checking if package \"$1\" was updated"
        if package_updated "$1"; then
            echo "$1"
        fi
    else
        log_trace "Checking all the packages for an update"
        while read -r PKG; do
            if package_updated "$PKG"; then
                echo "$PKG"
            fi
        done <<< "$(list_local_packages)"
    fi
}

update_package() {
    DEPENDENCIES="$(get_update_dependencies "$1")"
    declare -A DATA_PKG

    while read -r PKG; do
        if data_pkg_exists "$PKG"; then
            echo "Uninstalling \"$PKG\""
            #uninstall_package_exec "$PKG"
            DATA_PKG["$PKG"]=1
        fi
    done <<< "$DEPENDENCIES" 

    echo "Purging \"$1\""
    #purge_package_exec "$1"

    while read -r PKG; do
        if ${DATA_PKG["$PKG"]+_}; then
            echo "Installing \"$PKG\""
            # install_package_exec "$PKG"
        elif [ "$1" == "$PKG" ]; then
            echo "Pulling \"$PKG\""
            # pull_package_exec "$PKG"
        fi
    done <<< "$(reverse "$DEPENDENCIES")" 
}

update_packages() {
    while read -r PKG; do
        if ! empty "$PKG"; then
            update_package "$PKG"
        fi
    done <<< "$(get_updated_packages "$1")"
}

update_check() {
    USAGE_CMD="update"
    USAGE_CMD_SYNOPSIS="<package>|--all"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking update command preconditions"

    case "$1" in
        --all|"")
            ;;
        --*)
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid option: $1"
            ;;
        *)
            PKG_PATH=$EPM_PKG_PATH/$1
            if ! is_package "$1"; then
                command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
            elif ! dir_exists $PKG_PATH; then
                command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Package $1 does not exist"
            fi
    esac
}

update() {
    log_debug "Executing the update command"

    update_check "$1"

    case "$1" in
        --all|"")
            update_packages ""
            ;;
        *)
            update_packages "$1"
            ;;
    esac
}

status_check() {
    USAGE_CMD="status"
    USAGE_CMD_SYNOPSIS="<code>"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking status command preconditions"

    case "$1" in
        "-ib"|"-ub"|"--install-begin"|"--uninstall-begin")
            if empty "$2"; then
                command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package"
            elif ! is_package "$2"; then
                command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$2\""
            fi
            ;;
        "-ie"|"-ue"|"--install-end"|"--uninstall-end")
            ;;
        -*)
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid status message"
            ;;
        *)
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the status message"
            ;;
    esac
}

status() {
    log_debug "Executing the status command with \"$1\""

    status_check "$1" "$2"

    case "$1" in
        "-ib"|"--install-begin")
            install_begin "$2"
            ;;
        "-ie"|"--install-end")
            install_end
            ;;
        "-ub"|"--uninstall-begin")
            uninstall_begin "$2"
            ;;
        "-ue"|"--uninstall-end")
            uninstall_end
            ;;
    esac
}

list_check() {
    USAGE_CMD="list"
    USAGE_CMD_SYNOPSIS="[--all]|[-l|--local]|[-r|--remote]|[-i|--installed]"
    USAGE_CMD_DESCRIPTION=""
    
    check

    log_debug "Checking list command preconditions"

    case "$1" in
        "--all"|"")
            ;;
        "-l"|"--local")
            ;;
        "-r"|"--remote")
            ;;
        "-i"|"--installed")
            ;;
        *)
            command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid option: $1"
            ;;
    esac
}

list_local_packages() {
    PKG_PATH="$EPM_PKG_PATH"

    dir_list "$PKG_PATH"
}

list_installed_packages() {
    data_pkg_list
}

list_remote_packages() {
    EPM_PKG_SRV="$(var_get $EPM_PKG_SRV_KEY)"
    if [[ $EPM_PKG_SRV == file://* ]]; then
        DIR=${EPM_PKG_SRV#*file://}
        for FILE in $DIR/*.pkg; do 
            if [[ "$FILE" == *-$OS_NIX\.$PKG_EXT || "$FILE" == *-$OS_ALL\.$PKG_EXT ]]; then
                replace "$(basename $FILE)" "(.*)-($OS_ALL|$OS_NIX)\.$PKG_EXT" "\1"
            fi
        done
    fi
}

list_exec() {
    MODE="$1"
    MODE="${MODE:-"--all"}"
    declare -A PACKAGES

    if [ "$MODE" = "--all" ] || [ "$MODE" = "-r" ] || [ "$MODE" = "--remote" ]; then 
        REMOTE_PKG="$(list_remote_packages)"
        while read -r PKG; do
            if ! empty "$PKG"; then
                PACKAGES["$PKG"]="REMOTE"
            fi
        done <<< "$REMOTE_PKG"
    fi

    if [ "$MODE" = "--all" ] || [ "$MODE" = "-l" ] || [ "$MODE" = "--local" ]; then
        LOCAL_PKG="$(list_local_packages)"
        while read -r PKG; do
            if ! empty "$PKG"; then
                PACKAGES["$PKG"]="LOCAL"
            fi
        done <<< "$LOCAL_PKG"
    fi

    if [ "$MODE" = "--all" ] || [ "$MODE" = "-i" ] || [ "$MODE" = "--installed" ]; then 
        INSTALLED_PKG="$(list_installed_packages)"
        while read -r PKG; do
            if ! empty "$PKG"; then
                PACKAGES["$PKG"]="INSTALLED"
            fi
        done <<< "$INSTALLED_PKG"
    fi

    for PKG in ${!PACKAGES[@]}; do
        printf "%s %s\n" "$PKG" "${PACKAGES["$PKG"]}"
    done | sort -k1 | print_table2 "Name" "Status"
}

list() {
    log_debug "Executing the list command"

    list_check "$1"

    list_exec "$1"
}

metadata_options() {
    local OPTION_GET="\t--get\t\tget package metadata property value: name value"
    local OPTION_LIST="\t--list\t\tlists all the package metadata properties"
    local OPTIONS="$OPTION_GET\n$OPTION_LIST"

    printf "%b\n" "$OPTIONS"
}

metadata_get_check() {
    local USAGE_CMD="metadata <package> --get"
    local USAGE_CMD_SYNOPSIS="<name> [value]"
    local USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking metadata-get command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

metadata_get() {
    local GET_PKG="$1"
    local GET_NAME="$2"
    local GET_DEFAULT_VALUE="${3:-}"

    log_debug "Executing metadata-get command with \"$GET_PKG\", \"$CONFIG_GET_NAME\" and \"$GET_DEFAULT_VALUE\""

    metadata_get_check "$GET_NAME"
    
    local GET_VALUE="$(pkg_metadata_get_prop "$GET_PKG" "$GET_NAME")"
    GET_VALUE="${GET_VALUE:-"$GET_DEFAULT_VALUE"}"

    echo "$GET_VALUE"
}

metadata_default_check() {
    USAGE_CMD="metadata <package>"
    USAGE_CMD_SYNOPSIS="<name> [value]"
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking metadata-default command preconditions"
    
    if empty $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

metadata_default() {
    local DEFAULT_PKG="$1"
    local DEFAULT_NAME="$2"
    local DEFAULT_VALUE="$3"
    
    log_debug "Executing the metadata-default command with \"$DEFAULT_PKG\", \"$DEFAULT_NAME\" and \"$DEFAULT_VALUE\""

    metadata_default_check "$DEFAULT_NAME" "$DEFAULT_VALUE"

    pkg_metadata_get_prop "$DEFAULT_PKG" "$DEFAULT_NAME"
}

metadata_list_check() {
    local USAGE_CMD="metadata <package> --list"
    local USAGE_CMD_SYNOPSIS=""
    local USAGE_CMD_DESCRIPTION=""

    log_debug "Checking metadata-list command preconditions"
}

metadata_list() {
    local LIST_PKG="$1"

    log_debug "Executing the metadata-list command with \"$LIST_PKG\""

    metadata_list_check

    pkg_metadata_list_prop "$LIST_PKG" | print_table2 "Property" "Value" 
}

metadata_check() {
    local USAGE_CMD="metadata"
    local USAGE_CMD_SYNOPSIS="<package> [name] <value> | <package> [option]"
    local USAGE_CMD_DESCRIPTION="\nOptions:\n$(metadata_options)"

    check

    log_debug "Checking $USAGE_CMD command preconditions"
    
    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    elif empty "$2"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name or an option"
    fi
}

metadata() {
    log_debug "Executing the metadata command with package \"$1\" and command \"$2\""

    metadata_check "$1" "$2"
    
    case "$2" in
        --get)
            metadata_get "$1" "$3" "$4"
            ;;
        --list)
            metadata_list "$1"
            ;;
        *)
            metadata_default "$1" "$2" "$3"
            ;;
    esac
}

config_options() {
    local OPTION_ADD="\t--add\t\tadd a new package property: name value"
    local OPTION_REMOVE="\t--remove\tremove a package property: name"
    local OPTION_GET="\t--get\t\tget a package property value: name value"
    local OPTION_SET="\t--set\t\tset a package property value: name value"
    local OPTION_LIST="\t--list\t\tlists all the package properties"
    local OPTIONS="$OPTION_ADD\n$OPTION_REMOVE\n$OPTION_GET\n$OPTION_SET\n$OPTION_LIST"

    printf "%b\n" "$OPTIONS"
}

config_add_check() {
    local USAGE_CMD="config <package> --add"
    local USAGE_CMD_SYNOPSIS="<name> <value>"
    local USAGE_CMD_DESCRIPTION=""
   
    log_debug "Checking config-add command preconditions"

    if empty "$1" || empty "$2"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name and a value"
    fi
}

config_add() {
    local ADD_PKG="$1"
    local ADD_NAME="$2"
    local ADD_VALUE="$3"    

    log_debug "Executing config-add command with \"$ADD_PKG\", \"$ADD_NAME\" and \"$ENV_ADD_VALUE\""

    config_add_check "$ADD_NAME" "$ADD_VALUE"

    if pkg_config_exists "$ADD_PKG" "$ADD_NAME" && pkg_config_exists_prop "$ADD_PKG" "$ADD_NAME"; then
        pkg_config_set_prop "$ADD_PKG" "$ADD_NAME" "$ADD_VALUE"
    else
        pkg_config_add_prop "$ADD_PKG" "$ADD_NAME" "$ADD_VALUE"
    fi
}

config_remove_check() {
    local USAGE_CMD="config <package> --remove"
    local USAGE_CMD_SYNOPSIS="<name>"
    local USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking config-remove command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

config_remove() {
    local REMOVE_PKG="$1"
    local REMOVE_NAME="$2"

    log_debug "Executing config-remove command with \"$REMOVE_PKG\", \"$REMOVE_NAME\""

    env_remove_check "$REMOVE_NAME"

    if pkg_config_exists "$REMOVE_PKG" "$REMOVE_NAME" && pkg_config_exists_prop "$REMOVE_PKG" "$REMOVE_NAME"; then
        pkg_config_remove_prop "$REMOVE_PKG" "$REMOVE_NAME"
    fi
}

config_get_check() {
    local USAGE_CMD="config <package> --get"
    local USAGE_CMD_SYNOPSIS="<name> [value]"
    local USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking config-get command preconditions"

    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

config_get() {
    local GET_PKG="$1"
    local GET_NAME="$2"
    local GET_DEFAULT_VALUE="${3:-}"

    log_debug "Executing config-get command with \"$GET_PKG\", \"$CONFIG_GET_NAME\" and \"$GET_DEFAULT_VALUE\""

    config_get_check "$GET_NAME"
    
    local GET_VALUE="$(pkg_config_get_prop "$GET_PKG" "$GET_NAME")"
    GET_VALUE="${GET_VALUE:-"$GET_DEFAULT_VALUE"}"

    echo "$GET_VALUE"
}

config_set_check() {
    local USAGE_CMD="config <package> --set"
    local USAGE_CMD_SYNOPSIS="<name> <value>"
    local USAGE_CMD_DESCRIPTION=""

    log_debug "Checking config-set command preconditions"
   
    if empty "$1" || empty "$2"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name and a value"
    fi
}

config_set() {
    local SET_PKG="$1"
    local SET_NAME="$2"
    local SET_VALUE="$3"

    log_debug "Executing config-set command with \"$SET_PKG\", \"$SET_NAME\" and \"$SET_VALUE\""

    config_set_check "$SET_NAME" "$SET_VALUE"

    if pkg_config_exists "$SET_PKG" "$SET_NAME" && pkg_config_exists_prop "$SET_PKG" "$SET_NAME"; then
        pkg_config_set_prop "$SET_PKG" "$SET_NAME" "$SET_VALUE"
    else
        pkg_config_add_prop "$SET_PKG" "$SET_NAME" "$SET_VALUE"
    fi
}

config_default_check() {
    USAGE_CMD="config <package>"
    USAGE_CMD_SYNOPSIS="<name> [value]"
    USAGE_CMD_DESCRIPTION=""

    log_debug "Checking config-default command preconditions"
    
    if empty $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name"
    fi
}

config_default() {
    local DEFAULT_PKG="$1"
    local DEFAULT_NAME="$2"
    local DEFAULT_VALUE="$3"
    
    log_debug "Executing the config-default command with \"$DEFAULT_PKG\", \"$DEFAULT_NAME\" and \"$DEFAULT_VALUE\""

    config_default_check "$DEFAULT_NAME" "$DEFAULT_VALUE"

    if empty "$DEFAULT_VALUE"; then
        pkg_config_get_prop "$DEFAULT_PKG" "$DEFAULT_NAME"
    elif pkg_config_exists_prop "$DEFAULT_PKG" "$DEFAULT_NAME"; then
        pkg_config_set_prop "$DEFAULT_PKG" "$DEFAULT_NAME" "$DEFAULT_VALUE"
    else        
        pkg_config_add_prop "$DEFAULT_PKG" "$DEFAULT_NAME" "$DEFAULT_VALUE"
    fi
}

config_list_check() {
    local USAGE_CMD="config <package> --list"
    local USAGE_CMD_SYNOPSIS=""
    local USAGE_CMD_DESCRIPTION=""

    log_debug "Checking config-list command preconditions"
}

config_list() {
    local LIST_PKG="$1"

    log_debug "Executing the config-list command with \"$LIST_PKG\""

    config_list_check

    pkg_config_list_prop "$LIST_PKG" | print_table2 "Property" "Value"
}

config_check() {
    local USAGE_CMD="config"
    local USAGE_CMD_SYNOPSIS="<package> [name] <value> | <package> [option]"
    local USAGE_CMD_DESCRIPTION="\nOptions:\n$(config_options)"

    check

    log_debug "Checking $USAGE_CMD command preconditions"
    
    if empty "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify the package"
    elif ! is_package "$1"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "Invalid package name: \"$1\""
    elif empty "$2"; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must specify a name or an option"
    fi
}

config() {
    log_debug "Executing the config command with package \"$1\" and command \"$2\""

    config_check "$1" "$2"
    
    case "$2" in
        --add)
            config_add "$1" "$3" "$4"
            ;;
        --remove)
            config_remove "$1" "$3"
            ;;
        --get)
            config_get "$1" "$3" "$4"
            ;;
        --set)
            config_set "$1" "$3" "$4"
            ;;                
        --list)
            config_list "$1"
            ;;
        *)
            config_default "$1" "$2" "$3"
            ;;
    esac
}

version() {
    log_debug "Executing the version command"

    echo -e "$PROGRAM_NAME version $VERSION_NUMBER"
}

manual_page() {
    MANUAL_CMD="$1"
    COMMAND_UPPER=${MANUAL_CMD^^}
    MANUAL_NAME="$2"
    MANUAL_SYNOPSIS="$3"
    MANUAL_DESCRIPTION="$4"
    MANUAL_OPTIONS="$5"
    
    HEADER_LEFT_MSG="${PROGRAM_NAME^^}-$COMMAND_UPPER"
    HEADER_CENTER_MSG="${PROGRAM_NAME^} Manual"
    HEADER_RIGHT_MSG="${PROGRAM_NAME^^}-$COMMAND_UPPER"
    let HEADER_CENTER_COLS=$(( (${#HEADER_CENTER_MSG} + $TERM_COLS) / 2))-${#HEADER_LEFT_MSG}
    let HEADER_RIGHT_COLS=$TERM_COLS-${#HEADER_RIGHT_MSG}-$HEADER_CENTER_COLS-1

    FOOTER_LEFT_MSG="$PROGRAM_NAME $VERSION_NUMBER"
    FOOTER_CENTER_MSG="$VERSION_DATE"
    FOOTER_RIGHT_MSG="${PROGRAM_NAME^^}-$COMMAND_UPPER"
    let FOOTER_CENTER_COLS=$(( (${#FOOTER_CENTER_MSG} + $TERM_COLS) / 2))-${#FOOTER_LEFT_MSG}
    let FOOTER_RIGHT_COLS=$TERM_COLS-${#FOOTER_RIGHT_MSG}-$FOOTER_CENTER_COLS-1

    clear

    printf "%s%${HEADER_CENTER_COLS}s%${HEADER_RIGHT_COLS}s\n\n\n\n" "$HEADER_LEFT_MSG" "$HEADER_CENTER_MSG" "$HEADER_RIGHT_MSG"
    printf "%s%s%s\n" "$TERM_BOLD$TERM_RED" "NAME" "$TERM_NORMAL"
    printf "\t%s-%s - %s\n\n" "$PROGRAM_NAME" "$MANUAL_CMD" "$MANUAL_NAME"
    printf "%s%s%s\n" "$TERM_BOLD$TERM_RED" "SYNOPSIS" "$TERM_NORMAL"
    printf "\t%s%s%s %s\n\n\n" "$TERM_BOLD$TERM_YELLOW" "$PROGRAM_FILE $MANUAL_CMD" "$TERM_NORMAL" "$MANUAL_SYNOPSIS"
    printf "%s%s%s\n" "$TERM_BOLD$TERM_RED" "DESCRIPTION" "$TERM_NORMAL"
    printf "\t%s\n\n\n" "$MANUAL_DESCRIPTION"

    if ! empty $MANUAL_OPTIONS; then
        printf "%s%s%s\n" "$TERM_BOLD$TERM_RED" "OPTIONS" "$TERM_NORMAL"
        printf "%b\n\n\n" "$MANUAL_OPTIONS"
    fi

    printf "%s%${FOOTER_CENTER_COLS}s%${FOOTER_RIGHT_COLS}s\n" "$FOOTER_LEFT_MSG" "$FOOTER_CENTER_MSG" "$FOOTER_RIGHT_MSG"
}

help_init() {
    COMMAND="init"
    NAME="Inits ${PROGRAM_NAME}"
    SYNOPSIS="<url>"
    DESCRIPTION="Initializes a ${PROGRAM_NAME} store in the current directory"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_env() {
    COMMAND="env"
    NAME="Get and set $PROGRAM_NAME variables"
    SYNOPSIS="[option]|<name>|<name> <value>"
    DESCRIPTION="You can add/remove/get/set variables with this command"
    OPTIONS=$(env_options)
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION" "$OPTIONS"
}

help_pull() {
    COMMAND="pull"
    NAME="Pulls a package from the $PROGRAM_NAME server"
    SYNOPSIS="<package>"
    DESCRIPTION="The package is retrieved from the $PROGRAM_NAME server only if is not already available localy in the pakage path ($EPM_PKG_PATH) or in the staging path ($EPM_STG_PATH). After obtaining the package the data is decompressed to the pakage path"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_install() {
    COMMAND="install"
    NAME="Installs a $PROGRAM_NAME package"
    SYNOPSIS="<package>"
    DESCRIPTION="Installs a package. This command executes a pull if the package does not exists locally. Also, if the package is already installed it is uninstalled first"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_uninstall() {
    COMMAND="uninstall"
    NAME="Uninstalls a $PROGRAM_NAME package"
    SYNOPSIS="<PACKAGE>"
    DESCRIPTION="Uninstalls a package. If this package has child packages they are uninstalled also. This child packages are identified as all the packages that start with the current package name and are suffixed by an \"_\" followed by a name"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_purge() {
    COMMAND="purge"
    NAME="Purges a $PROGRAM_NAME package"
    SYNOPSIS="<PACKAGE>"
    DESCRIPTION="Purges a package, i.e. uninstalls and removes it from the local package cache. If this package has child packages they are uninstalled (but not purged). This child packages are identified as all the packages that start with the current package name and are suffixed by an \"_\" followed by a name"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_pack() {
    COMMAND="pack"
    NAME="Creates a $PROGRAM_NAME package"
    SYNOPSIS="<PACKAGE>"
    DESCRIPTION="Creates a package for all the environments listed in that package path. The package is composed of two files, one stores the package data (binaries and configurations) and other is the computed checksum of the package directory. If the package has a custom build script it is used to create the package binary"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_push() {
    COMMAND="push"
    NAME="Pushes a $PROGRAM_NAME package to the server"
    SYNOPSIS="<PACKAGE>"
    DESCRIPTION="Uploads a package to a server"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_update() {
    COMMAND="update"
    NAME="Updates a $PROGRAM_NAME package or all the packages"
    SYNOPSIS="<PACKAGE>"
    DESCRIPTION="Checks if one or more packages are up-to-date with the current version at the server. If the computed checksum of the package directory differs from the one stored in the package server, the previous version is uninstalled, and replaced by the new version"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_metadata() {
    COMMAND="metadata"
    NAME="Get $PROGRAM_NAME package metadata"
    SYNOPSIS="<package> [option]|<package> <name>"
    DESCRIPTION="You can get/list package metadata with this command"
    OPTIONS="$(metadata_options)"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_config() {
    COMMAND="config"
    NAME="Get and set $PROGRAM_NAME configurations"
    SYNOPSIS="<package> [option]|<package> <name>|<package> <name> <value>"
    DESCRIPTION="You can add/remove/get/set/list package configurations with this command"
    OPTIONS="$(config_options)"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_list() {
    COMMAND="list"
    NAME="Lists all ${PROGRAM_NAME} packages installed"
    SYNOPSIS=""
    DESCRIPTION="Lists all ${PROGRAM_NAME} packages installed in the system"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_version() {
    COMMAND="version"
    NAME="Displays $PROGRAM_NAME version"
    SYNOPSIS=""
    DESCRIPTION="Displays program version"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_help() {
    COMMAND="help"
    NAME="Display $PROGRAM_NAME help information"
    SYNOPSIS="[COMMAND]"
    DESCRIPTION="With no COMMAND given, the synopsis of the $PROGRAM_NAME command and a list of the most commonly used ${PROGRAM_NAME^} commands are printed on the standard output"
    
    manual_page "$COMMAND" "$NAME" "$SYNOPSIS" "$DESCRIPTION"
}

help_invalid_command() {
    printf "No manual entry for $1"
}

help_check() {
    USAGE_CMD="help"
    USAGE_CMD_SYNOPSIS="<command>"
    USAGE_CMD_DESCRIPTION=""
    
    log_debug "Checking help command preconditions"

    if empty $1; then
        command_usage "$USAGE_CMD" "$USAGE_CMD_SYNOPSIS" "$USAGE_CMD_DESCRIPTION" "You must especify a command"
    fi
}

help() {
    log_debug "Executing the help command for \"$1\""

    help_check $1

    case $1 in
        version)
            help_version
            ;;
        help)
            help_help
            ;;
        init)
            help_init
            ;;
        env)
            help_env
            ;;
        pull)
            help_pull
            ;;
        install)
            help_install
            ;;
        uninstall)
            help_uninstall
            ;;
        purge)
            help_purge
            ;;
        pack)
            help_pack
            ;;
        push)
            help_push
            ;;
        update)
            help_update
            ;;
        metadata)
            help_metadata
            ;;
        config)
            help_config
            ;;
        list)
            help_list
            ;;
        *)
            help_invalid_command "$1\n"
            ;;
    esac
}

error_invalid_command() {
    printf "$PROGRAM_FILE: '$1' is not a $PROGRAM_NAME command. See '$PROGRAM_FILE --help'."
    exit 1
}

CMD="$1"
case "$CMD" in
    env)
        env "$2" "$3" "$4"
        ;;
    lib)
        lib "$2" "$3"
        ;;
    init)
        init "$2"
        ;;
    pull)
        pull "$2"
        ;;
    -i|install)
        install "$2"
        ;;
    -r|require)
        require "$2" "$3"
        ;;
    -u|uninstall)
        uninstall "$2"
        ;;
    purge)
        purge "$2"
        ;;
    pack)
        pack "$2"
        ;;
    push)
        push "$2"
        ;;
    update)
        update "$2"
        ;;
    status)
        status "$2" "$3"
        ;;
    metadata)
        metadata "$2" "$3" "$4" "$5"
        ;;
    config)
        config "$2" "$3" "$4" "$5"
        ;;
    -l|list)
        list "$2"
        ;;
    --version|version)
        version    
        ;;
    --help|help)
        help "$2"
        ;;
    "")
        usage
        ;;
    *)
        error_invalid_command "$CMD"
    ;;
esac
